import EventEmitter from 'events';
import {
    ChannelInfo,
    ChannelEntry,
    CreationTime,
    SHA256Hash,
    SHA256IdHash,
    VersionedObjectResult,
    OneUnversionedObjectTypes,
    OneUnversionedObjectInterfaces,
    OneUnversionedObjectTypeNames,
    Person,
    Group
} from '@OneCoreTypes';
import {
    createSingleObjectThroughImpurePlan,
    createSingleObjectThroughPurePlan,
    getObject,
    getObjectByIdHash,
    onVersionedObj,
    getObjectWithType,
    VERSION_UPDATES,
    getObjectByIdObj
} from 'one.core/lib/storage';
import {calculateIdHashOfObj} from 'one.core/lib/util/object';
import {getInstanceOwnerIdHash} from 'one.core/lib/instance';
import {getAllValues} from 'one.core/lib/reverse-map-query';

/**
 * This represents a document but not the content,
 */
export type ChannelInformation = {
    hash: SHA256Hash; // This is the hash of the files object
};

export enum AccessGroupNames {
    partners= 'partners',
    clinic='clinic'
}

/**
 * Type defines a questionnaire response
 */
export type ObjectData<T> = {
    date: Date;
    id: string;
    author: SHA256IdHash<Person>;
    data: T;
    sharedWith: SHA256IdHash<Person>[];
};

/**
 * Assert that passed object has ChannelInfoResult type.
 *
 * This is required so that typescript stops displaying errors.
 *
 * @param {VersionedObjectResult} versionedObjectResult - the one object
 * @returns {VersionedObjectResult<ChannelInfo>} The same object, just typecasted in a safe way
 */
function isChannelInfoResult(
    versionedObjectResult: VersionedObjectResult
): versionedObjectResult is VersionedObjectResult<ChannelInfo> {
    return (versionedObjectResult as VersionedObjectResult<ChannelInfo>).obj.type === 'ChannelInfo';
}

/**
 * This model implements a document storage that stores the time of creation.
 */
export default class ChannelManager extends EventEmitter {
    private readonly channelsIds: SHA256IdHash<ChannelInfo>[];
    private personId: SHA256IdHash<Person> | undefined;

    constructor() {
        super();
        this.channelsIds = [];
    }

    /**
     * Init this instance. This has to be called after the one instance is initialized.
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async init(): Promise<void> {
        this.personId = getInstanceOwnerIdHash();
        await this.createAccessGroup(AccessGroupNames.partners);
        await this.createAccessGroup(AccessGroupNames.clinic);
        onVersionedObj.addListener((result: VersionedObjectResult) => {
            if (isChannelInfoResult(result)) {
                this.emit('updated', result.obj.id);
            }
        });


    }

    // ######## Channel management ########

    /**
     * Create a new channel.
     *
     * @param {string} channelId - The id of the channel TODO: the name needs to be autogenerated based on the
     *                                                          person signature or key
     */
    async createChannel(channelId: string): Promise<void> {
        try {
            // Get the ChannelInfo from the database
            const channelInfoIdHash = await calculateIdHashOfObj({
                type: 'ChannelInfo',
                id: channelId,
                owner: this.personId
            });
            await getObjectByIdHash<ChannelInfo>(channelInfoIdHash);
        } catch (ignore) {
            const channelResponse = (await createSingleObjectThroughPurePlan(
                {module: '@module/createChannel'},
                channelId,
                this.personId
            )) as VersionedObjectResult<ChannelInfo>;
            this.channelsIds.push(channelResponse.idHash);
            this.emit('updated');
        }
    }

    // ######## Put data into the channel ########

    /**
     * Post a new object to a channel.
     *
     * @param {string} channelId - The id of the channel to post to
     * @param {OneUnversionedObjectTypes} data - The object to post to the channel
     * @param {SHA256IdHash<Person>} owner
     */
    async postToChannel<T extends OneUnversionedObjectTypes>(
        channelId: string,
        data: T,
        owner?: SHA256IdHash<Person>
    ): Promise<void> {
        /** if you want to post to a different owner channel **/
        if (owner) {
            await createSingleObjectThroughImpurePlan(
                {module: '@module/postToChannel'},
                channelId,
                data,
                owner
            );
        } else {
            /** posting to your channel **/
            await createSingleObjectThroughImpurePlan(
                {module: '@module/postToChannel'},
                channelId,
                data,
                this.personId
            );
        }
    }

    // ######## Get data from the channel ########

    /**
     * Create an iterator that iterates over all items in a channel from future to past.
     *
     * @param {string} channelId - The channel for which to create the iterator
     */
    async *objectIterator(
        channelId: string
    ): AsyncIterableIterator<ObjectData<OneUnversionedObjectTypes>> {
        // Get the corresponding channel info object
        const channelInfoIdHash = await calculateIdHashOfObj({
            type: 'ChannelInfo',
            id: channelId
        });
        const channelInfo = (await getObjectByIdHash<ChannelInfo>(channelInfoIdHash)).obj;
        let channelEntryHash = channelInfo.head;

        // Iterate over the whoe list and append it to the output array
        while (channelEntryHash) {
            // Forward channelEntryHash to next element in chain
            // eslint-disable-next-line no-await-in-loop
            const channelEntry = await getObject<ChannelEntry>(channelEntryHash);
            channelEntryHash = channelEntry.previous;

            const persons: SHA256IdHash<Person>[] = [];

            // Extract the data of current element
            // eslint-disable-next-line no-await-in-loop
            const creationTime: CreationTime = await getObject<CreationTime>(channelEntry.data);
            // eslint-disable-next-line no-await-in-loop
            const channelAccessLink = await getAllValues(channelInfoIdHash, true, 'IdAccess');

            channelAccessLink.forEach(async (value) => {
                const accessObject = await getObjectWithType(value.toHash, 'IdAccess');
                const person = accessObject.person;
                persons.push(...person);
            });

            // eslint-disable-next-line no-await-in-loop
            const data = await getObject(creationTime.data);
            const obj = <ObjectData<OneUnversionedObjectTypes>>{
                date: new Date(creationTime.timestamp),
                id: creationTime.data,
                data: data,
                author: this.personId,
                sharedWith: persons
            };

            yield obj;
        }
    }

    /**
     * Create an iterator that iterates over all items of a specific type in a channel from future to past.
     *
     * @param {string} channelId - The channel for which to create the iterator
     * @param {T} type - The type of the elements to iterate
     */
    async *objectIteratorWithType<T extends OneUnversionedObjectTypeNames>(
        channelId: string,
        type: T
    ): AsyncIterableIterator<ObjectData<OneUnversionedObjectInterfaces[T]>> {
        function hasRequestedType(
            obj: ObjectData<OneUnversionedObjectTypes>
        ): obj is ObjectData<OneUnversionedObjectInterfaces[T]> {
            return obj.data.type === type;
        }

        for await (const obj of this.objectIterator(channelId)) {
            if (hasRequestedType(obj)) {
                yield obj;
            }
        }
    }

    /**
     * Get all data from a channel.
     *
     * In Ascending order! (TODO: add a switch for that)
     *
     * @param {string} channelId - The id of the channel to read from
     */
    async getObjects(channelId: string): Promise<ObjectData<OneUnversionedObjectTypes>[]> {
        const objects: ObjectData<OneUnversionedObjectTypes>[] = [];

        for await (const obj of this.objectIterator(channelId)) {
            objects.push(obj);
        }

        // We have to reverse the array, because the oldest element must be at the beginning
        return objects.reverse();
    }

    /**
     * Get all data from a channel.
     *
     * In Ascending order! (TODO: add a switch for that)
     *
     * @param {string}  channelId - The id of the channel to read from
     * @param {T}       type - Type of objects to retrieve. If type does not match the object is skipped.
     */
    async getObjectsWithType<T extends OneUnversionedObjectTypeNames>(
        channelId: string,
        type: T
    ): Promise<ObjectData<OneUnversionedObjectInterfaces[T]>[]> {
        const objects: ObjectData<OneUnversionedObjectInterfaces[T]>[] = [];

        for await (const obj of this.objectIteratorWithType(channelId, type)) {
            objects.push(obj);
        }

        // We have to reverse the array, because the oldest element must be at the beginning
        return objects.reverse();
    }

    /**
     * Obtain a specific object from a channel.
     *
     * This is a very inefficient implementation, because it iterates over the chain.
     * In the future it would be better to just pick the object with the passed hash.
     * But this only works when we have working reverse maps for getting the metadata.
     * The other option would be to use the hash of the indexed metadata as id, then
     * we don't have the reverse map problem.
     *
     * @param {string} channelId - The id of the channel to post to
     * @param {string} id - id of the object to extract, usually this is a hash of the
     *                      object itself or a related object.
     */
    async getObjectById(
        channelId: string,
        id: string
    ): Promise<ObjectData<OneUnversionedObjectTypes>> {
        for await (const obj of this.objectIterator(channelId)) {
            if (obj.id === id) {
                return obj;
            }
        }
        throw Error('Object not found in current chain');
    }

    /**
     * Obtain a specific object from a channel.
     *
     * This is a very inefficient implementation, because it iterates over the chain.
     * In the future it would be better to just pick the object with the passed hash.
     * But this only works when we have working reverse maps for getting the metadata.
     * The other option would be to use the hash of the indexed metadata as id, then
     * we don't have the reverse map problem.
     *
     * @param {string} channelId - The id of the channel to post to
     * @param {string} id - id of the object to extract, usually this is a hash of the
     *                      object itself or a related object.
     * @param {T}      type - Type of objects to retrieve. If type does not match an
     *                        error is thrown.
     *
     *
     */
    async getObjectWithTypeById<T extends OneUnversionedObjectTypeNames>(
        channelId: string,
        id: string,
        type: T
    ): Promise<ObjectData<OneUnversionedObjectInterfaces[T]>> {
        for await (const obj of this.objectIteratorWithType(channelId, type)) {
            if (obj.id === id) {
                return obj;
            }
        }
        throw Error("Object not found in current chain, or the type of the object didn't match");
    }

    /** Return the list with all the channel ids created
     *
     * @returns {SHA256IdHash<ChannelInfo>}
     */
    getChannelsIds(): SHA256IdHash<ChannelInfo>[] {
        return this.channelsIds;
    }

    /** Get a list of channels. */
    // eslint-disable-next-line @typescript-eslint/require-await
    async channels(): Promise<ChannelInformation[]> {
        return [];
    }

    // ############## ACCESS STUFF THAT SHOULD BE IN A DIFFERENT MODEL ##############

    /**
     * @param {string} name
     * @param {SHA256IdHash<Person>} personId
     * @returns {Promise<void>}
     */
    async addPersonToAccessGroup(name: AccessGroupNames, personId: SHA256IdHash<Person>): Promise<void> {
        const group = await this.getAccessGroupByName(name);
        /** add the person only if it does not exist and prevent unnecessary one updates **/
        if (
            (group.obj.person.find(
                (accPersonIdHash: SHA256IdHash<Person>) => accPersonIdHash === personId
            )) === undefined
        ) {
            group.obj.person.push(personId);
            await createSingleObjectThroughPurePlan(
                {
                    module: '@one/identity',
                    versionMapPolicy: {'*': VERSION_UPDATES.NONE_IF_LATEST}
                },
                group.obj
            );
        }
    }

    /**
     *
     * @param {string} name
     * @returns {Promise<VersionedObjectResult<Group>>}
     */
    async getAccessGroupByName(name: AccessGroupNames): Promise<VersionedObjectResult<Group>> {
        return await getObjectByIdObj({type: 'Group', name: name});
    }

    /**
     *
     * @param {string} name
     * @returns {Promise<void>}
     */
    async createAccessGroup(name: AccessGroupNames): Promise<void> {
        try {
            await getObjectByIdObj({type: 'Group', name: name});
        } catch (ignored) {
            await createSingleObjectThroughPurePlan(
                {
                    module: '@one/identity',
                    versionMapPolicy: {'*': VERSION_UPDATES.NONE_IF_LATEST}
                },
                {
                    type: 'Group',
                    name: name,
                    person: []
                }
            );
        }
    }
}
