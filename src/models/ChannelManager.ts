import EventEmitter from 'events';
import {
    ChannelInfo,
    ChannelEntry,
    CreationTime,
    SHA256Hash,
    SHA256IdHash,
    VersionedObjectResult,
    OneUnversionedObjectTypes,
    OneUnversionedObjectInterfaces,
    OneUnversionedObjectTypeNames,
    Person,
    Group,
    ChannelRegistry
} from '@OneCoreTypes';
import {
    createSingleObjectThroughImpurePlan,
    createSingleObjectThroughPurePlan,
    getObject,
    getObjectByIdHash,
    onVersionedObj,
    getObjectWithType,
    VERSION_UPDATES,
    getObjectByIdObj
} from 'one.core/lib/storage';
import {calculateHashOfObj, calculateIdHashOfObj} from 'one.core/lib/util/object';
import {getInstanceOwnerIdHash} from 'one.core/lib/instance';
import {getAllValues} from 'one.core/lib/reverse-map-query';
import {serializeWithType} from 'one.core/lib/util/promise';

/**
 * This represents a document but not the content,
 */
export type ChannelInformation = {
    hash: SHA256Hash; // This is the hash of the files object
};

export enum ChannelEvent {
    UpdatedChannelInfo = 'UPDATED_CHANNEL_INFO'
}

/**
 *  This represents the possible orders of sorting the returned data from the channel.
 */
export enum Order {
    Ascending = 1,
    Descending = 2
}

/**
 * Type defines the query options that can be specified while retrieving data from the channel.
 */
export type QueryOptions = {
    owner?: SHA256IdHash<Person>;
    orderBy?: Order;
    from?: Date;
    to?: Date;
    count?: number;
};

/**
 * Type defines a questionnaire response
 */
export type ObjectData<T> = {
    date: number;
    id: string;
    author: SHA256IdHash<Person>;
    data: T;
    sharedWith: SHA256IdHash<Person>[];
};

/**
 * Assert that passed object has ChannelInfoResult type.
 *
 * This is required so that typescript stops displaying errors.
 *
 * @param {VersionedObjectResult} versionedObjectResult - the one object
 * @returns {VersionedObjectResult<ChannelInfo>} The same object, just typecasted in a safe way
 */
function isChannelInfoResult(
    versionedObjectResult: VersionedObjectResult
): versionedObjectResult is VersionedObjectResult<ChannelInfo> {
    return (versionedObjectResult as VersionedObjectResult<ChannelInfo>).obj.type === 'ChannelInfo';
}

/**
 * This model implements a document storage that stores the time of creation.
 */
export default class ChannelManager extends EventEmitter {
    // @ts-ignore
    private personId: SHA256IdHash<Person>;

    // @todo
    // Hooks -> Whenever you receive a new ChannelInfo check if it's already there, if not add it
    // emit event

    constructor() {
        super();
    }

    /**
     * Init this instance. This has to be called after the one instance is initialized.
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async init(): Promise<void> {
        const ownerIdHash = getInstanceOwnerIdHash();
        await ChannelManager.getChannelRegistry();
        if (ownerIdHash === undefined) {
            throw new Error('Owner idHash cannot be undefined');
        }
        this.registerHooks();

        this.personId = ownerIdHash;
    }

    // ######## Channel management ########

    /**
     * Create a new channel.
     *
     * @param {string} channelId - The id of the channel TODO: the name needs to be autogenerated based on the
     *                                                          person signature or key
     */
    async createChannel(channelId: string): Promise<void> {
        try {
            // Get the ChannelInfo from the database
            const channelInfoIdHash = await calculateIdHashOfObj({
                type: 'ChannelInfo',
                id: channelId,
                owner: this.personId
            });
            await getObjectByIdHash<ChannelInfo>(channelInfoIdHash);
        } catch (ignore) {
            await createSingleObjectThroughPurePlan(
                {module: '@module/createChannel'},
                channelId,
                this.personId
            );
            this.emit('updated');
        }
    }

    // ######## Put data into the channel ########

    /**
     * Post a new object to a channel.
     *
     * @param {string} channelId - The id of the channel to post to
     * @param {OneUnversionedObjectTypes} data - The object to post to the channel
     * @param {SHA256IdHash<Person>} owner
     */
    async postToChannel<T extends OneUnversionedObjectTypes>(
        channelId: string,
        data: T,
        owner?: SHA256IdHash<Person>
    ): Promise<void> {
        /** if you want to post to a different owner channel **/
        if (owner) {
            await createSingleObjectThroughImpurePlan(
                {module: '@module/postToChannel'},
                channelId,
                owner,
                data
            );
        } else {
            /** posting to your channel **/
            await createSingleObjectThroughImpurePlan(
                {module: '@module/postToChannel'},
                channelId,
                this.personId,
                data
            );
        }
    }

    // ######## Get data from the channel ########

    async *objectIteratorForManyChannels(
        channelId: string,
        queryOptions?: QueryOptions
    ): AsyncIterableIterator<ObjectData<OneUnversionedObjectTypes>> {
        const channels =
            queryOptions === undefined || queryOptions.owner === undefined
                ? await this.findChannelsForSpecificId(channelId)
                : [
                      await getObjectByIdObj({
                          type: 'ChannelInfo',
                          id: channelId,
                          owner: queryOptions.owner
                      })
                  ];

        const iterators = await Promise.all(
            channels.map(async (channel: VersionedObjectResult<ChannelInfo>) => {
                const iterator = this.objectIterator(channel.obj.id, {
                    ...queryOptions,
                    owner: channel.obj.owner
                });

                return async () => {
                    const newValue = await iterator.next();
                    if (!newValue.done) {
                        return newValue.value;
                    } else {
                        return null;
                    }
                };
            })
        );
        for await (const obj of this.runIterators(iterators, {...queryOptions})) {
            yield obj;
        }
    }

    /**
     * !!! Main Iterator
     * Create an iterator that iterates over all items in a channel from future to past.
     *
     * @param {string} channelId - The channel for which to create the iterator
     * @param {QueryOptions} queryOptions
     */
    async *objectIterator(
        channelId: string,
        queryOptions: QueryOptions
    ): AsyncIterableIterator<ObjectData<OneUnversionedObjectTypes>> {
        let objectsCount = 0;

        // Get the corresponding channel info object
        const channelInfoIdHash = await calculateIdHashOfObj({
            type: 'ChannelInfo',
            id: channelId,
            owner: queryOptions.owner
        });
        const channelInfo = (await getObjectByIdHash<ChannelInfo>(channelInfoIdHash)).obj;
        let channelEntryHash = channelInfo.head;

        // Iterate over the whoe list and append it to the output array
        while (channelEntryHash) {
            // Forward channelEntryHash to next element in chain
            // eslint-disable-next-line no-await-in-loop
            const channelEntry = await getObject<ChannelEntry>(channelEntryHash);
            channelEntryHash = channelEntry.previous;

            // Extract the data of current element
            // eslint-disable-next-line no-await-in-loop
            const creationTime: CreationTime = await getObject<CreationTime>(channelEntry.data);
            // eslint-disable-next-line no-await-in-loop
            const channelAccessLink = await getAllValues(channelInfoIdHash, true, 'IdAccess');

            if (queryOptions !== undefined) {
                if (
                    queryOptions.to !== undefined &&
                    creationTime.timestamp > queryOptions.to.getTime()
                ) {
                    continue;
                }

                if (
                    queryOptions.from !== undefined &&
                    creationTime.timestamp < queryOptions.from.getTime()
                ) {
                    break;
                }

                if (queryOptions.count !== undefined && objectsCount >= queryOptions.count) {
                    break;
                }
            }

            const persons: SHA256IdHash<Person>[] = (
                await Promise.all(
                    channelAccessLink.map(async (value) => {
                        const accessObject = await getObjectWithType(value.toHash, 'IdAccess');
                        return accessObject.person;
                    })
                )
            ).reduce((acc, val) => acc.concat(val), []);

            // eslint-disable-next-line no-await-in-loop
            const data = await getObject(creationTime.data);
            const obj = <ObjectData<OneUnversionedObjectTypes>>{
                date: creationTime.timestamp,
                id: creationTime.data,
                data: data,
                author: this.personId,
                sharedWith: Array.from([...new Set(persons)])
            };

            objectsCount++;
            yield obj;
        }
    }

    /**
     *
     * Get all data from a channel.
     *
     * In Ascending order! (TODO: add a switch for that)
     * // if owner === undefined , get all the channelInfos with the channelId
     * @param {string} channelId - The id of the channel to read from
     * @param {QueryOptions} queryOptions
     */
    async getObjects(
        channelId: string,
        queryOptions?: QueryOptions
    ): Promise<ObjectData<OneUnversionedObjectTypes>[]> {
        const objects: ObjectData<OneUnversionedObjectTypes>[] = [];
        if (queryOptions !== undefined && queryOptions.owner !== undefined) {
            for await (const obj of this.objectIterator(channelId, queryOptions)) {
                objects.push(obj);
            }
            return objects.reverse();
        } else {
            for await (const obj of this.objectIteratorForManyChannels(channelId, {
                ...queryOptions
            })) {
                objects.push(obj);
            }
            return objects.reverse();
        }
    }

    /**
     * Get all data from a channel.
     *
     * In Ascending order! (TODO: add a switch for that)
     *
     * @param {string}  channelId - The id of the channel to read from
     * @param {T}       type - Type of objects to retrieve. If type does not match the object is skipped.
     * @param {QueryOptions} queryOptions
     */
    async getObjectsWithType<T extends OneUnversionedObjectTypeNames>(
        channelId: string,
        type: T,
        queryOptions?: QueryOptions
    ): Promise<ObjectData<OneUnversionedObjectInterfaces[T]>[]> {
        function hasRequestedType(
            obj: ObjectData<OneUnversionedObjectTypes>
        ): obj is ObjectData<OneUnversionedObjectInterfaces[T]> {
            return obj.data.type === type;
        }

        const objects: ObjectData<OneUnversionedObjectInterfaces[T]>[] = [];

        if (queryOptions !== undefined && queryOptions.owner !== undefined) {
            for await (const obj of this.objectIterator(channelId, queryOptions)) {
                if (hasRequestedType(obj)) {
                    objects.push(obj);
                }
            }
            return objects.reverse();
        } else {
            for await (const obj of this.objectIteratorForManyChannels(channelId, {
                ...queryOptions
            })) {
                if (hasRequestedType(obj)) {
                    objects.push(obj);
                }
            }
            return objects.reverse();
        }
    }

    /**
     * Obtain a specific object from a channel.
     *
     * This is a very inefficient implementation, because it iterates over the chain.
     * In the future it would be better to just pick the object with the passed hash.
     * But this only works when we have working reverse maps for getting the metadata.
     * The other option would be to use the hash of the indexed metadata as id, then
     * we don't have the reverse map problem.
     *
     * @param {string} channelId - The id of the channel to post to
     * @param {string} id - id of the object to extract, usually this is a hash of the
     *                      object itself or a related object.
     * @param {QueryOptions} queryOptions
     */
    async getObjectById(
        channelId: string,
        id: string,
        queryOptions?: QueryOptions
    ): Promise<ObjectData<OneUnversionedObjectTypes>[]> {
        const objects: ObjectData<OneUnversionedObjectTypes>[] = [];

        if (queryOptions !== undefined && queryOptions.owner !== undefined) {
            for await (const obj of this.objectIterator(channelId, queryOptions)) {
                if (obj.id === id) {
                    objects.push(obj);
                }
            }
            if (objects.length === 0) {
                throw Error('Object not found in current chain');
            }

            return objects.reverse();
        } else {
            for await (const obj of this.objectIteratorForManyChannels(channelId, {
                ...queryOptions
            })) {
                if (obj.id === id) {
                    objects.push(obj);
                }
            }
            if (objects.length === 0) {
                throw Error('Object not found in current chain');
            }

            return objects.reverse();
        }
    }

    /**
     * Obtain a specific object from a channel.
     *
     * This is a very inefficient implementation, because it iterates over the chain.
     * In the future it would be better to just pick the object with the passed hash.
     * But this only works when we have working reverse maps for getting the metadata.
     * The other option would be to use the hash of the indexed metadata as id, then
     * we don't have the reverse map problem.
     *
     * @param {string} channelId - The id of the channel to post to
     * @param {string} id - id of the object to extract, usually this is a hash of the
     *                      object itself or a related object.
     * @param {T}      type - Type of objects to retrieve. If type does not match an
     *                        error is thrown.
     * @param {QueryOptions} queryOptions
     *
     */
    async getObjectWithTypeById<T extends OneUnversionedObjectTypeNames>(
        channelId: string,
        id: string,
        type: T,
        queryOptions?: QueryOptions
    ): Promise<ObjectData<OneUnversionedObjectInterfaces[T]>[]> {
        function hasRequestedType(
            obj: ObjectData<OneUnversionedObjectTypes>
        ): obj is ObjectData<OneUnversionedObjectInterfaces[T]> {
            return obj.data.type === type;
        }

        const objects: ObjectData<OneUnversionedObjectInterfaces[T]>[] = [];

        if (queryOptions !== undefined && queryOptions.owner !== undefined) {
            for await (const obj of this.objectIterator(channelId, queryOptions)) {
                if (hasRequestedType(obj) && obj.id === id) {
                    objects.push(obj);
                }
            }
            return objects.reverse();
        } else {
            for await (const obj of this.objectIteratorForManyChannels(channelId, {
                ...queryOptions
            })) {
                if (hasRequestedType(obj) && obj.id === id) {
                    objects.push(obj);
                }
            }
            return objects.reverse();
        }
    }

    /**
     *
     * @param channelId
     * @param {SHA256IdHash<Person>} owner
     * @returns {Promise<ChannelInformation[]>}
     */
    async channels(channelId: string, owner?: SHA256IdHash<Person>): Promise<ChannelInformation[]> {
        if (owner === undefined) {
            return (await this.findChannelsForSpecificId(channelId)).map(
                (channelInfo: VersionedObjectResult<ChannelInfo>) => ({
                    hash: channelInfo.hash
                })
            );
        } else {
            return [await getObjectByIdObj({type: 'ChannelInfo', id: channelId, owner: owner})].map(
                (channelInfo: VersionedObjectResult<ChannelInfo>) => ({
                    hash: channelInfo.hash
                })
            );
        }
    }

    /**
     * @BETA First implementation of the merging algorithm
     * @param {SHA256Hash<ChannelInfo>} firstChannel
     * @param {SHA256Hash<ChannelInfo>} secondaryChannel
     * @returns {Promise<VersionedObjectResult<ChannelInfo>>}
     */
    public async mergeChannels(
        firstChannel: SHA256Hash<ChannelInfo>,
        secondaryChannel: SHA256Hash<ChannelInfo>
    ): Promise<VersionedObjectResult<ChannelInfo>> {
        /** explode the given hashes **/
        const explodedFirstChannel = await getObject(firstChannel);
        const explodedSecondChannel = await getObject(secondaryChannel);

        /** Persisted channel entries that are in the secondaryChannel **/
        const previouslySecondaryChannelEntries: ChannelEntry[] = [];
        /** sorted channel entries from both of the channels **/
        const allChannelEntries: ChannelEntry[] = [];

        /** if the id & owner of the channels are not equal, throw an error **/
        if (
            explodedFirstChannel.id !== explodedSecondChannel.id &&
            explodedFirstChannel.owner !== explodedSecondChannel.owner
        ) {
            throw new Error('Error: in order to merge the channels they must be the same');
        }

        /** get the first ChannelEntry Hash in the chain **/
        let firstChannelHead: SHA256Hash<ChannelEntry> | undefined = (await getObject(firstChannel))
            .head;
        let secondChannelHead: SHA256Hash<ChannelEntry> | undefined = (
            await getObject(secondaryChannel)
        ).head;

        do {
            let firstChannelEntryObject: ChannelEntry;
            let secondChannelEntryObject: ChannelEntry;

            /**
             * For all the edge cases, construct the chain from the non undefined element
             * If both channels head are undefined, start from the chain root
             */

            /** edge case **/
            if (firstChannelHead === undefined && secondChannelHead !== undefined) {
                return await this.createChannelChain(
                    allChannelEntries,
                    secondChannelHead,
                    explodedFirstChannel
                );
            }

            /** edge case **/
            if (secondChannelHead === undefined && firstChannelHead !== undefined) {
                return await this.createChannelChain(
                    allChannelEntries,
                    firstChannelHead,
                    explodedFirstChannel
                );
            }

            /** edge case **/
            if (secondChannelHead === undefined && firstChannelHead === undefined) {
                return await this.createChannelChain(
                    allChannelEntries,
                    undefined,
                    explodedFirstChannel
                );
            }

            // @ts-ignore
            firstChannelEntryObject = await getObject(firstChannelHead);
            // @ts-ignore
            secondChannelEntryObject = await getObject(secondChannelHead);

            /** push the ChannelEntry object in the list in order to find the common history entry in the future **/
            previouslySecondaryChannelEntries.push(secondChannelEntryObject);

            const firstChannelEntryData = await getObject(firstChannelEntryObject.data);
            const secondChannelEntryData = await getObject(secondChannelEntryObject.data);

            /** find the common history entry **/
            const commonHistory = previouslySecondaryChannelEntries.find(
                (entry: ChannelEntry) => entry.previous === firstChannelEntryObject.previous
            );

            /** if the common history entry was found in the past or present, construct the chain from it **/
            if (
                commonHistory !== undefined ||
                firstChannelEntryObject.previous === secondChannelEntryObject.previous
            ) {
                return await this.createChannelChain(
                    allChannelEntries,
                    firstChannelHead,
                    explodedFirstChannel
                );
            } else {
                /** if not, add both elements in the sorted entries list **/
                allChannelEntries.splice(
                    await this.getTheRightIndexInTheChannelEntries(
                        allChannelEntries,
                        firstChannelEntryData.timestamp
                    ),
                    0,
                    firstChannelEntryObject
                );
                allChannelEntries.splice(
                    await this.getTheRightIndexInTheChannelEntries(
                        allChannelEntries,
                        secondChannelEntryData.timestamp
                    ),
                    0,
                    secondChannelEntryObject
                );
            }

            /** continue **/
            // @ts-ignore
            firstChannelHead = (await getObject(firstChannelHead)).previous;
            // @ts-ignore
            secondChannelHead = (await getObject(secondChannelHead)).previous;
        } while (true);
    }

    /**
     * @description Creates a ChannelInfo from a given ChannelEntry List and a root
     * @param {ChannelEntry[]} allEntries
     * @param {SHA256Hash<ChannelEntry> | undefined} commonPoint
     * @param {ChannelInfo} mainChannelInfo
     * @returns {Promise<VersionedObjectResult<ChannelInfo>> }
     */
    private async createChannelChain(
        allEntries: ChannelEntry[],
        commonPoint: SHA256Hash<ChannelEntry> | undefined,
        mainChannelInfo: ChannelInfo
    ): Promise<VersionedObjectResult<ChannelInfo>> {
        const reversedEntries = allEntries.reverse();

        let lastChannelEntry;

        for (let i = 0; i < reversedEntries.length; i++) {
            lastChannelEntry = await createSingleObjectThroughPurePlan(
                {
                    module: '@one/identity',
                    versionMapPolicy: {'*': VERSION_UPDATES.NONE_IF_LATEST}
                },
                {
                    type: 'ChannelEntry',
                    data: await calculateHashOfObj(reversedEntries[i]),
                    previous:
                        i === 0 ? commonPoint : await calculateHashOfObj(reversedEntries[i - 1])
                }
            );
        }
        return await createSingleObjectThroughPurePlan(
            {
                module: '@one/identity',
                versionMapPolicy: {'*': VERSION_UPDATES.NONE_IF_LATEST}
            },
            {
                type: 'ChannelInfo',
                id: mainChannelInfo.id,
                owner: mainChannelInfo.owner,
                head: await calculateHashOfObj(lastChannelEntry.obj)
            }
        );
    }

    /**
     * Helper function to determine the index where a ChannelEntry should be added
     * @param {ChannelEntry[]} channelEntries
     * @param {number} timestamp
     * @returns {Promise<number>}
     */
    private async getTheRightIndexInTheChannelEntries(
        channelEntries: ChannelEntry[],
        timestamp: number
    ): Promise<number> {
        let low = 0,
            high = channelEntries.length;

        while (low < high) {
            let mid = (low + high) >>> 1;
            const item = await getObject(channelEntries[mid].data);
            if (item.timestamp < timestamp) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    /**
     * @description Yield values from the iterators
     * @param iterators
     * @param queryOptions
     * @returns {AsyncIterableIterator<ObjectData<OneUnversionedObjectTypes>>}
     */
    private async *runIterators(
        iterators: Function[],
        queryOptions: QueryOptions
    ): AsyncIterableIterator<ObjectData<OneUnversionedObjectTypes>> {
        let currentValues = [];
        let count = 0;

        for (const iterator of iterators) {
            currentValues.push(await iterator());
        }


        if (currentValues.length === 1) {
            yield currentValues[0];
            for (;;) {
                const yieldedValue = await iterators[0]();
                if (yieldedValue !== null) {
                    yield yieldedValue;
                } else {
                    break;
                }
            }
            return;
        }


        for (;;) {
            // determine the largest element in currentValues
            let maxIndex = -1;
            let maxValue = -1;

            let selectedItem: ObjectData<OneUnversionedObjectTypes> | null = null;

            for (let i = 0; i < currentValues.length; i++) {
                // @ts-ignore
                if (currentValues[i] !== null && currentValues[i].date > maxValue) {
                    // @ts-ignore
                    maxValue = currentValues[i].date;
                    maxIndex = i;
                    selectedItem = currentValues[i];
                }
            }

            if (maxIndex === -1 || selectedItem === null) {
                break;
            }

            if (queryOptions !== undefined && queryOptions.count !== undefined) {
                if (count === queryOptions.count) {
                    break;
                }
            }

            currentValues[maxIndex] = await iterators[maxIndex]();
            ++count;

            yield selectedItem;
        }
    }

    private async getExplodedChannelInfosFromRegistry(): Promise<
        VersionedObjectResult<ChannelInfo>[]
    > {
        const channelRegistry = await ChannelManager.getChannelRegistry();
        return await Promise.all(
            channelRegistry.obj.channels.map(
                async (channelInfoIdHash: SHA256IdHash<ChannelInfo>) => {
                    return await getObjectByIdHash(channelInfoIdHash);
                }
            )
        );
    }

    private async findChannelsForSpecificId(
        channelId: string
    ): Promise<VersionedObjectResult<ChannelInfo>[]> {
        return (await this.getExplodedChannelInfosFromRegistry()).filter(
            (channelInfo: VersionedObjectResult<ChannelInfo>) => channelInfo.obj.id === channelId
        );
    }

    private registerHooks(): void {
        onVersionedObj.addListener(async (caughtObject: VersionedObjectResult) => {
            if (isChannelInfoResult(caughtObject)) {
                await this.addChannelToTheChannelRegistry(caughtObject.idHash);
                this.emit(ChannelEvent.UpdatedChannelInfo, caughtObject.obj.id);
            }
        });
    }


    /**
     *
     * @param channelIdHash
     * @returns {Promise<void>}
     */
    private async addChannelToTheChannelRegistry(
        channelIdHash: SHA256IdHash<ChannelInfo>
    ): Promise<void> {
        const channelRegistry = await ChannelManager.getChannelRegistry();
        if (
            channelRegistry.obj.channels.find(
                (channelEntryIdHash: SHA256IdHash<ChannelInfo>) =>
                    channelEntryIdHash === channelIdHash
            ) === undefined
        ) {
            channelRegistry.obj.channels.push(channelIdHash);
            return await serializeWithType('ChannelRegistry', async () => {
                await createSingleObjectThroughPurePlan(
                    {
                        module: '@one/identity',
                        versionMapPolicy: {'*': VERSION_UPDATES.NONE_IF_LATEST}
                    },
                    channelRegistry.obj
                );
            });
        }
    }

    /**
     * @returns {Promise<VersionedObjectResult<ChannelRegistry>>}
     */
    static async getChannelRegistry(): Promise<VersionedObjectResult<ChannelRegistry>> {
        return await serializeWithType('ChannelRegistry', async () => {
            try {
                return await getObjectByIdObj({type: 'ChannelRegistry', id: 'ChannelRegistry'});
            } catch (e) {
                return await createSingleObjectThroughPurePlan(
                    {
                        module: '@one/identity',
                        versionMapPolicy: {'*': VERSION_UPDATES.NONE_IF_LATEST}
                    },
                    {
                        type: 'ChannelRegistry',
                        id: 'ChannelRegistry',
                        channels: []
                    }
                );
            }
        });
    }
}
