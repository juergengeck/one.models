import EventEmitter from 'events';
import {
    ChannelInfo,
    ChannelEntry,
    CreationTime,
    SHA256Hash,
    SHA256IdHash,
    VersionedObjectResult,
    OneUnversionedObjectTypes,
    OneUnversionedObjectInterfaces,
    OneUnversionedObjectTypeNames,
    Person,
    Group,
    ChannelRegistry
} from '@OneCoreTypes';
import {
    createSingleObjectThroughImpurePlan,
    createSingleObjectThroughPurePlan,
    getObject,
    getObjectByIdHash,
    onVersionedObj,
    getObjectWithType,
    VERSION_UPDATES,
    getObjectByIdObj
} from 'one.core/lib/storage';
import {calculateIdHashOfObj} from 'one.core/lib/util/object';
import {getInstanceOwnerIdHash} from 'one.core/lib/instance';
import {getAllValues} from 'one.core/lib/reverse-map-query';
import {serializeWithType} from 'one.core/lib/util/promise';

/**
 * This represents a document but not the content,
 */
export type ChannelInformation = {
    hash: SHA256Hash; // This is the hash of the files object
};

export enum AccessGroupNames {
    partners = 'partners',
    clinic = 'clinic'
}

export enum ChannelEvent {
    UpdatedChannelInfo = 'UPDATED_CHANNEL_INFO'
}

/**
 *  This represents the possible orders of sorting the returned data from the channel.
 */
export enum Order {
    Ascending = 1,
    Descending = 2
}

/**
 * Type defines the query options that can be specified while retrieving data from the channel.
 */
export type QueryOptions = {
    owner?: SHA256IdHash<Person>;
    orderBy?: Order;
    from?: Date;
    to?: Date;
    count?: number;
};

/**
 * Type defines a questionnaire response
 */
export type ObjectData<T> = {
    date: number;
    id: string;
    author: SHA256IdHash<Person>;
    data: T;
    sharedWith: SHA256IdHash<Person>[];
};

/**
 * Assert that passed object has ChannelInfoResult type.
 *
 * This is required so that typescript stops displaying errors.
 *
 * @param {VersionedObjectResult} versionedObjectResult - the one object
 * @returns {VersionedObjectResult<ChannelInfo>} The same object, just typecasted in a safe way
 */
function isChannelInfoResult(
    versionedObjectResult: VersionedObjectResult
): versionedObjectResult is VersionedObjectResult<ChannelInfo> {
    return (versionedObjectResult as VersionedObjectResult<ChannelInfo>).obj.type === 'ChannelInfo';
}

/**
 * This model implements a document storage that stores the time of creation.
 */
export default class ChannelManager extends EventEmitter {
    // @ts-ignore
    private personId: SHA256IdHash<Person>;

    // @todo
    // Hooks -> Whenever you receive a new ChannelInfo check if it's already there, if not add it
    // emit event

    constructor() {
        super();
        this.registerHooks();
    }

    /**
     * Init this instance. This has to be called after the one instance is initialized.
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async init(): Promise<void> {
        const ownerIdHash = getInstanceOwnerIdHash();

        if (ownerIdHash === undefined) {
            throw new Error('Owner idHash cannot be undefined');
        }
        this.personId = ownerIdHash;
        await this.createAccessGroup(AccessGroupNames.partners);
        await this.createAccessGroup(AccessGroupNames.clinic);
        onVersionedObj.addListener((result: VersionedObjectResult) => {
            if (isChannelInfoResult(result)) {
                this.emit('updated', result.obj.id);
            }
        });
    }

    // ######## Channel management ########

    /**
     * Create a new channel.
     *
     * @param {string} channelId - The id of the channel TODO: the name needs to be autogenerated based on the
     *                                                          person signature or key
     */
    async createChannel(channelId: string): Promise<void> {
        try {
            // Get the ChannelInfo from the database
            const channelInfoIdHash = await calculateIdHashOfObj({
                type: 'ChannelInfo',
                id: channelId,
                owner: this.personId
            });
            await getObjectByIdHash<ChannelInfo>(channelInfoIdHash);
        } catch (ignore) {
            await createSingleObjectThroughPurePlan(
                {module: '@module/createChannel'},
                channelId,
                this.personId
            );
            this.emit('updated');
        }
    }

    // ######## Put data into the channel ########

    /**
     * Post a new object to a channel.
     *
     * @param {string} channelId - The id of the channel to post to
     * @param {OneUnversionedObjectTypes} data - The object to post to the channel
     * @param {SHA256IdHash<Person>} owner
     */
    async postToChannel<T extends OneUnversionedObjectTypes>(
        channelId: string,
        data: T,
        owner?: SHA256IdHash<Person>
    ): Promise<void> {
        /** if you want to post to a different owner channel **/
        if (owner) {
            await createSingleObjectThroughImpurePlan(
                {module: '@module/postToChannel'},
                channelId,
                data,
                owner
            );
        } else {
            /** posting to your channel **/
            await createSingleObjectThroughImpurePlan(
                {module: '@module/postToChannel'},
                channelId,
                data,
                this.personId
            );
        }
    }

    // ######## Get data from the channel ########

    async *objectIteratorForManyChannels(
        channelId: string,
        queryOptions: QueryOptions
    ): AsyncIterableIterator<ObjectData<OneUnversionedObjectTypes>> {
        // queries ChannelInfos
        // -> list of owners who have a channel with the specified channelId
        const iterators = [];
        let currentValues = [];
        let count = 0;
        const channels = await this.findChannelsForSpecificId(channelId);

        for (const channel of channels) {
            iterators.push(async () => {
                const newValue = await this.objectIterator(channel.obj.id, queryOptions).next();
                if (!newValue.done) {
                    return newValue.value;
                } else {
                    return null;
                }
            });
        }

        for (const iterator of iterators) {
            currentValues.push(await iterator());
        }

        for (;;) {
            // determine the largest element in currentValues
            let maxIndex = -1;
            let maxValue = -1;

            let selectedItem: ObjectData<OneUnversionedObjectTypes> | null = null;

            for (let i = 0; i < currentValues.length; i++) {
                // @ts-ignore
                if (currentValues[i] !== null && currentValues[i].date > maxValue) {
                    // @ts-ignore
                    maxValue = currentValues[i].date;
                    maxIndex = i;
                    selectedItem = currentValues[i];
                }
            }

            if (maxIndex === -1 || selectedItem === null) {
                break;
            }

            if (queryOptions.count !== undefined) {
                if (count === queryOptions.count) {
                    break;
                }
            }

            currentValues[maxIndex] = await iterators[maxIndex]();
            ++count;

            yield selectedItem;
        }

        // find the largest (in time) element and yield it
        // advance only the iterator from which you picked the yielded item

        // find the largest (in time) element and yield it
        // advance only the iterator from which you picked the yielded item
    }

    /**
     * !!! Main Iterator
     * Create an iterator that iterates over all items in a channel from future to past.
     *
     * @param {string} channelId - The channel for which to create the iterator
     * @param {QueryOptions} queryOptions
     */
    async *objectIterator(
        channelId: string,
        queryOptions: QueryOptions
    ): AsyncIterableIterator<ObjectData<OneUnversionedObjectTypes>> {
        let objectsCount = 0;

        // Get the corresponding channel info object
        const channelInfoIdHash = await calculateIdHashOfObj({
            type: 'ChannelInfo',
            id: channelId,
            owner: queryOptions.owner
        });
        const channelInfo = (await getObjectByIdHash<ChannelInfo>(channelInfoIdHash)).obj;
        let channelEntryHash = channelInfo.head;

        // Iterate over the whoe list and append it to the output array
        while (channelEntryHash) {
            // Forward channelEntryHash to next element in chain
            // eslint-disable-next-line no-await-in-loop
            const channelEntry = await getObject<ChannelEntry>(channelEntryHash);
            channelEntryHash = channelEntry.previous;

            // Extract the data of current element
            // eslint-disable-next-line no-await-in-loop
            const creationTime: CreationTime = await getObject<CreationTime>(channelEntry.data);
            // eslint-disable-next-line no-await-in-loop
            const channelAccessLink = await getAllValues(channelInfoIdHash, true, 'IdAccess');

            if (queryOptions !== undefined) {
                if (
                    queryOptions.to !== undefined &&
                    creationTime.timestamp > queryOptions.to.getTime()
                ) {
                    continue;
                }

                if (
                    queryOptions.from !== undefined &&
                    creationTime.timestamp < queryOptions.from.getTime()
                ) {
                    break;
                }

                if (queryOptions.count !== undefined && objectsCount >= queryOptions.count) {
                    break;
                }
            }

            const persons: SHA256IdHash<Person>[] = (
                await Promise.all(
                    channelAccessLink.map(async (value) => {
                        const accessObject = await getObjectWithType(value.toHash, 'IdAccess');
                        return accessObject.person;
                    })
                )
            ).reduce((acc, val) => acc.concat(val), []);

            // eslint-disable-next-line no-await-in-loop
            const data = await getObject(creationTime.data);
            const obj = <ObjectData<OneUnversionedObjectTypes>>{
                date: creationTime.timestamp,
                id: creationTime.data,
                data: data,
                author: this.personId,
                sharedWith: Array.from([...new Set(persons)])
            };

            objectsCount++;

            yield obj;
        }
    }

    /**
     *
     * Get all data from a channel.
     *
     * In Ascending order! (TODO: add a switch for that)
     * // if owner === undefined , get all the channelInfos with the channelId
     * @param {string} channelId - The id of the channel to read from
     * @param {QueryOptions} queryOptions
     */
    async getObjects(
        channelId: string,
        queryOptions?: QueryOptions
    ): Promise<ObjectData<OneUnversionedObjectTypes>[]> {
        const objects: ObjectData<OneUnversionedObjectTypes>[] = [];

        if (queryOptions !== undefined && queryOptions.owner !== undefined) {
            for await (const obj of this.objectIterator(channelId, queryOptions)) {
                objects.push(obj);
            }
            return objects.reverse();
        } else {
            for await (const obj of this.objectIteratorForManyChannels(channelId, {
                ...queryOptions
            })) {
                objects.push(obj);
            }
            return objects.reverse();
        }
    }

    /**
     * Get all data from a channel.
     *
     * In Ascending order! (TODO: add a switch for that)
     *
     * @param {string}  channelId - The id of the channel to read from
     * @param {T}       type - Type of objects to retrieve. If type does not match the object is skipped.
     * @param {QueryOptions} queryOptions
     */
    async getObjectsWithType<T extends OneUnversionedObjectTypeNames>(
        channelId: string,
        type: T,
        queryOptions?: QueryOptions
    ): Promise<ObjectData<OneUnversionedObjectInterfaces[T]>[]> {
        function hasRequestedType(
            obj: ObjectData<OneUnversionedObjectTypes>
        ): obj is ObjectData<OneUnversionedObjectInterfaces[T]> {
            return obj.data.type === type;
        }

        const objects: ObjectData<OneUnversionedObjectInterfaces[T]>[] = [];

        if (queryOptions !== undefined && queryOptions.owner !== undefined) {
            for await (const obj of this.objectIterator(channelId, queryOptions)) {
                if (hasRequestedType(obj)) {
                    objects.push(obj);
                }
            }
            return objects.reverse();
        } else {
            for await (const obj of this.objectIteratorForManyChannels(channelId, {
                ...queryOptions
            })) {
                if (hasRequestedType(obj)) {
                    objects.push(obj);
                }
            }
            return objects.reverse();
        }
    }

    /**
     * Obtain a specific object from a channel.
     *
     * This is a very inefficient implementation, because it iterates over the chain.
     * In the future it would be better to just pick the object with the passed hash.
     * But this only works when we have working reverse maps for getting the metadata.
     * The other option would be to use the hash of the indexed metadata as id, then
     * we don't have the reverse map problem.
     *
     * @param {string} channelId - The id of the channel to post to
     * @param {string} id - id of the object to extract, usually this is a hash of the
     *                      object itself or a related object.
     * @param {QueryOptions} queryOptions
     */
    async getObjectById(
        channelId: string,
        id: string,
        queryOptions?: QueryOptions
    ): Promise<ObjectData<OneUnversionedObjectTypes>[]> {
        const objects: ObjectData<OneUnversionedObjectTypes>[] = [];

        if (queryOptions !== undefined && queryOptions.owner !== undefined) {
            for await (const obj of this.objectIterator(channelId, queryOptions)) {
                if (obj.id === id) {
                    objects.push(obj);
                }
            }
            if (objects.length === 0) {
                throw Error('Object not found in current chain');
            }

            return objects.reverse();
        } else {
            for await (const obj of this.objectIteratorForManyChannels(channelId, {
                ...queryOptions
            })) {
                if (obj.id === id) {
                    objects.push(obj);
                }
            }
            if (objects.length === 0) {
                throw Error('Object not found in current chain');
            }

            return objects.reverse();
        }
    }

    /**
     * Obtain a specific object from a channel.
     *
     * This is a very inefficient implementation, because it iterates over the chain.
     * In the future it would be better to just pick the object with the passed hash.
     * But this only works when we have working reverse maps for getting the metadata.
     * The other option would be to use the hash of the indexed metadata as id, then
     * we don't have the reverse map problem.
     *
     * @param {string} channelId - The id of the channel to post to
     * @param {string} id - id of the object to extract, usually this is a hash of the
     *                      object itself or a related object.
     * @param {T}      type - Type of objects to retrieve. If type does not match an
     *                        error is thrown.
     * @param {QueryOptions} queryOptions
     *
     */
    async getObjectWithTypeById<T extends OneUnversionedObjectTypeNames>(
        channelId: string,
        id: string,
        type: T,
        queryOptions?: QueryOptions
    ): Promise<ObjectData<OneUnversionedObjectInterfaces[T]>[]> {
        function hasRequestedType(
            obj: ObjectData<OneUnversionedObjectTypes>
        ): obj is ObjectData<OneUnversionedObjectInterfaces[T]> {
            return obj.data.type === type;
        }

        const objects: ObjectData<OneUnversionedObjectInterfaces[T]>[] = [];

        if (queryOptions !== undefined && queryOptions.owner !== undefined) {
            for await (const obj of this.objectIterator(channelId, queryOptions)) {
                if (hasRequestedType(obj) && obj.id === id) {
                    objects.push(obj);
                }
            }
            return objects.reverse();
        } else {
            for await (const obj of this.objectIteratorForManyChannels(channelId, {
                ...queryOptions
            })) {
                if (hasRequestedType(obj) && obj.id === id) {
                    objects.push(obj);
                }
            }
            return objects.reverse();
        }
    }

    /**
     *
     * @param channelId
     * @param {SHA256IdHash<Person>} owner
     * @returns {Promise<ChannelInformation[]>}
     */
    async channels(channelId: string, owner?: SHA256IdHash<Person>): Promise<ChannelInformation[]> {
        if (owner === undefined) {
            return (await this.findChannelsForSpecificId(channelId)).map(
                (channelInfo: VersionedObjectResult<ChannelInfo>) => ({
                    hash: channelInfo.hash
                })
            );
        } else {
            return [await getObjectByIdObj({type: 'ChannelInfo', id: channelId, owner: owner})].map(
                (channelInfo: VersionedObjectResult<ChannelInfo>) => ({
                    hash: channelInfo.hash
                })
            );
        }
    }

    private async getExplodedChannelInfosFromRegistry(): Promise<
        VersionedObjectResult<ChannelInfo>[]
    > {
        const channelRegistry = await ChannelManager.getChannelRegistry();
        return await Promise.all(
            channelRegistry.obj.channels.map(
                async (channelInfoIdHash: SHA256IdHash<ChannelInfo>) => {
                    return await getObjectByIdHash(channelInfoIdHash);
                }
            )
        );
    }

    private async findChannelsForSpecificId(
        channelId: string
    ): Promise<VersionedObjectResult<ChannelInfo>[]> {
        return (await this.getExplodedChannelInfosFromRegistry()).filter(
            (channelInfo: VersionedObjectResult<ChannelInfo>) => channelInfo.obj.id === channelId
        );
    }

    private registerHooks(): void {
        onVersionedObj.addListener(async (caughtObject: VersionedObjectResult) => {
            if (isChannelInfoResult(caughtObject)) {
                await this.addChannelToTheChannelRegistry(caughtObject.idHash);
                this.emit(ChannelEvent.UpdatedChannelInfo);
            }
        });
    }

    /**
     *
     * @param channelIdHash
     * @returns {Promise<void>}
     */
    private async addChannelToTheChannelRegistry(
        channelIdHash: SHA256IdHash<ChannelInfo>
    ): Promise<void> {
        const channelRegistry = await ChannelManager.getChannelRegistry();
        if (
            channelRegistry.obj.channels.find(
                (channelEntryIdHash: SHA256IdHash<ChannelInfo>) =>
                    channelEntryIdHash === channelIdHash
            ) === undefined
        ) {
            channelRegistry.obj.channels.push(channelIdHash);
            await createSingleObjectThroughPurePlan(
                {
                    module: '@one/identity',
                    versionMapPolicy: {'*': VERSION_UPDATES.NONE_IF_LATEST}
                },
                channelRegistry.obj
            );
        }
    }

    /**
     * @returns {Promise<VersionedObjectResult<ChannelRegistry>>}
     */
    static async getChannelRegistry(): Promise<VersionedObjectResult<ChannelRegistry>> {
        return await serializeWithType('ChannelRegistry', async () => {
            try {
                return await getObjectByIdObj({type: 'ChannelRegistry', id: 'ChannelRegistry'});
            } catch (e) {
                return await createSingleObjectThroughPurePlan(
                    {
                        module: '@one/identity',
                        versionMapPolicy: {'*': VERSION_UPDATES.NONE_IF_LATEST}
                    },
                    {
                        type: 'ChannelRegistry',
                        id: 'ChannelRegistry',
                        channels: []
                    }
                );
            }
        });
    }
    // ############## ACCESS STUFF THAT SHOULD BE IN A DIFFERENT MODEL ##############

    /**
     * @param {string} name
     * @param {SHA256IdHash<Person>} personId
     * @returns {Promise<void>}
     */
    async addPersonToAccessGroup(
        name: AccessGroupNames,
        personId: SHA256IdHash<Person>
    ): Promise<void> {
        const group = await this.getAccessGroupByName(name);
        /** add the person only if it does not exist and prevent unnecessary one updates **/
        if (
            group.obj.person.find(
                (accPersonIdHash: SHA256IdHash<Person>) => accPersonIdHash === personId
            ) === undefined
        ) {
            group.obj.person.push(personId);
            await createSingleObjectThroughPurePlan(
                {
                    module: '@one/identity',
                    versionMapPolicy: {'*': VERSION_UPDATES.NONE_IF_LATEST}
                },
                group.obj
            );
        }
    }

    /**
     *
     * @param {string} name
     * @returns {Promise<VersionedObjectResult<Group>>}
     */
    async getAccessGroupByName(name: AccessGroupNames): Promise<VersionedObjectResult<Group>> {
        return await getObjectByIdObj({type: 'Group', name: name});
    }

    /**
     *
     * @param {string} name
     * @returns {Promise<void>}
     */
    async createAccessGroup(name: AccessGroupNames): Promise<void> {
        try {
            await getObjectByIdObj({type: 'Group', name: name});
        } catch (ignored) {
            await createSingleObjectThroughPurePlan(
                {
                    module: '@one/identity',
                    versionMapPolicy: {'*': VERSION_UPDATES.NONE_IF_LATEST}
                },
                {
                    type: 'Group',
                    name: name,
                    person: []
                }
            );
        }
    }
}
