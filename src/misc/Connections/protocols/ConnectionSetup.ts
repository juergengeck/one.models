/**
 * This files implements the communication workflows needed for setting up encrypted connections.
 *
 * It provides functions to:
 * - connect to a target once
 * - continuously connecting to a target while (retrying e.g. when the target is offline)
 * - setup the encrypted channel for established websockets (incoming connections)
 */
import tweetnacl from 'tweetnacl';
import {createMessageBus} from '@refinio/one.core/lib/message-bus';
import {createWebSocket} from '@refinio/one.core/lib/system/websocket';
import {isFunction} from '@refinio/one.core/lib/util/type-checks-basic';
import {
    sendUnencryptedClientMessage,
    sendUnencryptedServerMessage,
    waitForUnencryptedClientMessage,
    waitForUnencryptedServerMessage
} from './CommunicationInitiationProtocol';
import Connection from '../Connection';
import EncryptionPlugin from '../plugins/EncryptionPlugin';
import {PongPlugin} from '../plugins/PingPongPlugin';
import {
    hexToUint8Array,
    uint8arrayToHexString
} from '@refinio/one.core/lib/util/arraybuffer-to-and-from-hex-string';

const MessageBus = createMessageBus('ConnectionSetup');

/**
 * The connection container that is returned whenever a new connection is established / accepted.
 */
type ConnectionInfo = {
    connection: Connection;
    myKey: Uint8Array;
    remoteKey: Uint8Array;
};

/**
 * A promise type that has an additional stop method that will stop the async operation and make the
 * promise reject.
 */
export type StoppablePromise<T> = Promise<T> & {stop: () => void};

/**
 * Establish an encrypted connection to a target.
 *
 * The shared key used for the encrypted connection is based on two new keypairs generated by
 * both participants. The public keys that need to be exchanged are encrypted with the passed
 * encrypt / decrypt functions.
 *
 * This ensures forward secrecy (because of a new set of keys for each connection) and man in
 * the middle protection (because the public keys are transported with encryption)
 *
 * TODO: At the moment the current workflow has the drawback, that the source and targetPublicKey
 *       are transmitted unencrypted in Phase 1. It doesn't hurt security, but a listening third
 *       party sees who communicates with whom which hurts privacy.
 *
 * @param url - Url to connect to
 * @param localPublicKey - Public key of ourselves
 * @param remotePublicKey - Public key of the target
 * @param encrypt - Encrypt function for exchanging temporary keys
 * @param decrypt - Decrypt function for exchanging temporary keys
 */
export async function connectWithEncryption(
    url: string,
    localPublicKey: Uint8Array,
    remotePublicKey: Uint8Array,
    encrypt: (text: Uint8Array) => Uint8Array,
    decrypt: (cypher: Uint8Array) => Uint8Array
): Promise<ConnectionInfo> {
    const connection = new Connection(createWebSocket(url));
    MessageBus.send(
        'debug',
        `${connection.id} connectWithEncryption(${url}, ${uint8arrayToHexString(
            localPublicKey
        )}, ${uint8arrayToHexString(remotePublicKey)})`
    );

    await connection.waitForOpen();

    try {
        // ######## Phase 1: Connection Establishment ########
        MessageBus.send('debug', `${connection.id}: Phase 1: establish connection`);

        // Phase 1.1: Request communication
        MessageBus.send('debug', `${connection.id}: Phase 1.1: send communication_request`);
        await sendUnencryptedClientMessage(connection, {
            command: 'communication_request',
            sourcePublicKey: uint8arrayToHexString(localPublicKey),
            targetPublicKey: uint8arrayToHexString(remotePublicKey)
        });

        // Phase 1.2: Wait for the other side to signal us that it is ready to receive data
        MessageBus.send('debug', `${connection.id}: Phase 1.2: wait for communication_ready`);
        await waitForUnencryptedServerMessage(connection, 'communication_ready');

        // ######## Phase 2: Setup encryption ########
        MessageBus.send('debug', `${connection.id}: Phase 2: exchange keys`);

        // Phase 2.1: Generate keypair and send the public key to the other side
        MessageBus.send(
            'debug',
            `${connection.id}: Phase 2.1: generate encrypt and send public key`
        );

        const tempKeyPair = tweetnacl.box.keyPair();
        await connection.send(encrypt(tempKeyPair.publicKey));

        // Phase 2.2: Wait for the public key from the other side
        MessageBus.send('debug', `${connection.id}: Phase 2.2: wait for and decrypt public key`);

        const publicKeyOther = decrypt(await connection.promisePlugin().waitForBinaryMessage());

        // Phase 2.3: Derive shared key and setup encrypted connection object
        MessageBus.send('debug', `${connection.id}: Phase 2.3: derive shared key`);

        const sharedKey = tweetnacl.box.before(publicKeyOther, tempKeyPair.secretKey);
        connection.addPlugin(new EncryptionPlugin(sharedKey, false), {before: 'promise'});
        connection.addPlugin(new PongPlugin(20000, 2000), {before: 'promise'});

        MessageBus.send(
            'debug',
            `${connection.id} connectWithEncryption(${url}, ${uint8arrayToHexString(
                localPublicKey
            )}, ${uint8arrayToHexString(remotePublicKey)}) - success`
        );
        return {
            connection,
            myKey: localPublicKey,
            remoteKey: remotePublicKey
        };
    } catch (e) {
        MessageBus.send(
            'debug',
            `${connection.id} connectWithEncryption(${url}, ${uint8arrayToHexString(
                localPublicKey
            )}, ${uint8arrayToHexString(remotePublicKey)}) - failure: ${e}`
        );
        connection.close(e.toString());
        throw e;
    }
}

/**
 * Establish an encrypted connection to a target - if not successful retries.
 *
 * This is exactly the same as connectWithEncryption, except that the returned promise does not
 * reject when the connection stablishment failed. In this case it just retires. There is only
 * one way to
 *
 * @param url
 * @param localPublicKey
 * @param remotePublicKey
 * @param encrypt
 * @param decrypt
 * @param retryTimeout
 */
export function connectWithEncryptionUntilSuccessful(
    url: string,
    localPublicKey: Uint8Array,
    remotePublicKey: Uint8Array,
    encrypt: (text: Uint8Array) => Uint8Array,
    decrypt: (cypher: Uint8Array) => Uint8Array,
    retryTimeout = 5000
): StoppablePromise<ConnectionInfo> {
    MessageBus.send(
        'log',
        `connectWithEncryptionUntilSuccessful(${url}, ${uint8arrayToHexString(
            localPublicKey
        )}, ${uint8arrayToHexString(remotePublicKey)})`
    );

    // eslint-disable-next-line func-style
    let stopLoop = (): void => undefined;

    async function startLoop(): Promise<ConnectionInfo> {
        let stopped = false;

        stopLoop = () => {
            stopped = true;
        };

        while (!stopped) {
            try {
                // Try to establish a connection
                // eslint-disable-next-line no-await-in-loop
                const connInfo = await connectWithEncryption(
                    url,
                    localPublicKey,
                    remotePublicKey,
                    encrypt,
                    decrypt
                );

                // If a connection was established after stop was called we still reject the
                // promise, because it makes caller code easier if stop() guarantees a reject.
                if (stopped) {
                    connInfo.connection.close('Stopped by user');
                    break;
                }

                MessageBus.send(
                    'log',
                    `${
                        connInfo.connection.id
                    } connectWithEncryptionUntilSuccessful(${url}, ${uint8arrayToHexString(
                        localPublicKey
                    )}, ${uint8arrayToHexString(remotePublicKey)}) - success`
                );

                return connInfo;
            } catch (ignore) {
                if (stopped) {
                    break;
                }

                // eslint-disable-next-line no-await-in-loop
                await new Promise<void>((resolve, reject) => {
                    const retryTimeoutHandle = setTimeout(() => {
                        stopLoop = () => {
                            stopped = true;
                        };
                        resolve();
                    }, retryTimeout);

                    stopLoop = () => {
                        clearTimeout(retryTimeoutHandle);
                        reject(new Error('Stopped by user'));
                    };
                });
            }
        }

        throw new Error('Stopped by user');
    }

    // Construct and return the stoppable promise
    const promise = startLoop() as StoppablePromise<ConnectionInfo>;

    // We can't use the stopHandler her directly, because it might change its value.
    promise.stop = () => {
        stopLoop();
    };

    return promise;
}

/**
 * Accept a connection and do the encryption handshaking to setup an encrypted connection.
 *
 * This is the opposite of connectWithEncryption, so for more information have a look at the
 * documentation of that function.
 * If something goes wrong the passed websocket connection will be closed.
 *
 * @param connection
 * @param allowedLocalPublicKeys
 * @param encrypt
 * @param decrypt
 */
export async function acceptWithEncryption(
    connection: Connection,
    allowedLocalPublicKeys: Uint8Array[],
    encrypt: (pubKeyOther: Uint8Array, text: Uint8Array) => Uint8Array,
    decrypt: (pubKeyOther: Uint8Array, cypher: Uint8Array) => Uint8Array
): Promise<ConnectionInfo> {
    MessageBus.send('log', `acceptWithEncryption(${connection.id})`);

    try {
        // ######## Phase 1: Connection Establishment ########
        MessageBus.send('debug', `${connection.id}: Phase 1: accept connection`);

        // Phase 1.1: Wait for the communication request
        MessageBus.send('debug', `${connection.id}: Phase 1.1: wait for communication_request`);

        const request = await waitForUnencryptedClientMessage(connection, 'communication_request');
        const targetPublicKey = hexToUint8Array(request.targetPublicKey);
        const sourcePublicKey = hexToUint8Array(request.sourcePublicKey);

        // Phase 1.2: Signal the other side that we are ready to receive messages
        MessageBus.send('debug', `${connection.id}: Phase 1.2: send communication_ready`);
        await sendUnencryptedServerMessage(connection, {command: 'communication_ready'});

        // ######## Special Phase: Check if we want to accept the other side ########
        MessageBus.send('debug', `${connection.id}: Phase 1.3: check our desire to communicate`);

        // Phase 1.3: Check whether the request has come through the right endpoint
        //            (someone might probe an anonymous endpoint for the real id)
        let rejectConnection = true;

        for (const allowedKey of allowedLocalPublicKeys) {
            if (tweetnacl.verify(targetPublicKey, allowedKey)) {
                rejectConnection = false;
                // No break here, so that the loop execution time stays constant
                // compared between success and failure.
                // It is not constant when the
                // number of allowed public keys changes, but for now it is not so bad, because
                // anonymous endpoints should only have one element.
            }
        }

        // Phase 1.4: Check whether our id wants to communicate with the other side
        // This step should also run in constant time ... but we can't decide it here. We would have to
        // 1) call a callback or
        // 2) we also get an array of allowed peers for a given public key
        // ... but let's do this later.
        // TODO: implement this step (select communication partners)
        MessageBus.send(
            'debug',
            `${connection.id}: Phase 1.3: ${rejectConnection ? 'rejected' : 'accepted'}`
        );

        // ######## Phase 2: Setup encryption ########
        MessageBus.send('debug', `${connection.id}: Phase 2: exchange keys`);

        // Phase 2.2: Wait for the public key from the other side
        MessageBus.send('debug', `${connection.id}: Phase 2.1: wait for and decrypt public key`);

        const publicKeyOther = decrypt(
            sourcePublicKey,
            await connection.promisePlugin().waitForBinaryMessage()
        );

        // Note that termination of a connection should always be done after the peer proved,
        // that it has the public key, but before we proved, that we have our public key. This
        // means that we don't expose any information about what identities we have, because the
        // following scenarios terminate at the same point in protocol and also if possible at
        // the exact same time (side channel timing attacks!)
        // - we don't know the person and don't want to communicate with it
        // - we are not the identity that the other side wants to connect to
        if (rejectConnection) {
            // noinspection ExceptionCaughtLocallyJS
            throw new Error('Connection request rejected.');
        }

        // Phase 2.2: Generate keypair and send the public key to the other side
        MessageBus.send(
            'debug',
            `${connection.id}: Phase 2.2: generate encrypt and send public key`
        );

        const tempKeyPair = tweetnacl.box.keyPair();
        await connection.send(encrypt(sourcePublicKey, tempKeyPair.publicKey));

        // Phase 2.3: Derive shared key and setup encrypted connection object
        MessageBus.send('debug', `${connection.id}: Phase 2.3: derive shared key`);

        const sharedKey = tweetnacl.box.before(publicKeyOther, tempKeyPair.secretKey);
        connection.addPlugin(new EncryptionPlugin(sharedKey, true), {before: 'promise'});
        connection.addPlugin(new PongPlugin(20000, 2000), {before: 'promise'});

        MessageBus.send(
            'log',
            `acceptWithEncryption(${connection.id}, ${uint8arrayToHexString(
                targetPublicKey
            )}, ${uint8arrayToHexString(publicKeyOther)}) - success`
        );
        return {
            connection,
            myKey: targetPublicKey,
            remoteKey: publicKeyOther
        };
    } catch (e) {
        MessageBus.send('log', `acceptWithEncryption(${connection.id}) - failure: ${e}`);
        connection.close(e && isFunction(e.toString) ? e.toString() : undefined);
        throw e;
    }
}
