/**
 * This files implements the communication workflows needed for setting up encrypted connections.
 *
 * It provides functions to:
 * - connect to a target once
 * - continuously connecting to a target while (retrying e.g. when the target is offline)
 * - setup the encrypted channel for established websockets (incoming connections)
 */
import tweetnacl from 'tweetnacl';
import {createMessageBus} from '@refinio/one.core/lib/message-bus';
import {createWebSocket} from '@refinio/one.core/lib/system/websocket';
import {isFunction} from '@refinio/one.core/lib/util/type-checks-basic';
import type {SymmetricCryptoApiWithKeys} from '@refinio/one.core/lib/crypto/SymmetricCryptoApi';
import {castToLocalPublicKey, castToRemotePublicKey} from '../ConnectionRoutesGroupMap';
import {
    sendUnencryptedClientMessage,
    sendUnencryptedServerMessage,
    waitForUnencryptedClientMessage,
    waitForUnencryptedServerMessage
} from './CommunicationInitiationProtocolMessages';
import Connection from '../../Connection/Connection';
import EncryptionPlugin from '../../Connection/plugins/EncryptionPlugin';
import {
    hexToUint8Array,
    uint8arrayToHexString
} from '@refinio/one.core/lib/util/arraybuffer-to-and-from-hex-string';
import PromisePlugin from '../../Connection/plugins/PromisePlugin';
import {KeepAlivePlugin} from '../../Connection/plugins/KeepAlivePlugin';
import FragmentationPlugin from '../../Connection/plugins/FragmentationPlugin';
import type {CryptoApi} from '@refinio/one.core/lib/crypto/CryptoApi';
import type {PublicKey} from '@refinio/one.core/lib/crypto/encryption';
import {ensurePublicKey} from '@refinio/one.core/lib/crypto/encryption';

const KEEPALIVE_TIMER = 20000;
const KEEPALIVE_TIMEOUT = 25000;
const FRAGMENTATION_CHUNKSIZE = 65536;

const MessageBus = createMessageBus('ConnectionSetup');

/**
 * The connection container that is returned whenever a new connection is established / accepted.
 */
type ConnectionInfo = {
    connection: Connection;
    myKey: PublicKey;
    remoteKey: PublicKey;
};

/**
 * A promise type that has an additional stop method that will stop the async operation and make the
 * promise reject.
 */
export type StoppablePromise<T> = Promise<T> & {stop: () => void};

/**
 * Establish an encrypted connection to a target.
 *
 * The shared key used for the encrypted connection is based on two new keypairs generated by
 * both participants. The public keys that need to be exchanged are encrypted with the passed
 * encrypt / decrypt functions.
 *
 * This ensures forward secrecy (because of a new set of keys for each connection) and man in
 * the middle protection (because the public keys are transported with encryption)
 *
 * TODO: At the moment the current workflow has the drawback, that the source and targetPublicKey
 *       are transmitted unencrypted in Phase 1. It doesn't hurt security, but a listening third
 *       party sees who communicates with whom which hurts privacy.
 *
 * @param url - Url to connect to
 * @param cryptoApi
 */
export async function connectWithEncryption(
    url: string,
    cryptoApi: SymmetricCryptoApiWithKeys
): Promise<ConnectionInfo> {
    const localPublicKey = castToLocalPublicKey(cryptoApi.localPublicKey);
    const remotePublicKey = castToRemotePublicKey(cryptoApi.remotePublicKey);

    const connection = new Connection(createWebSocket(url));
    MessageBus.send(
        'debug',
        `${connection.id} connectWithEncryption(${url}, ${localPublicKey}, ${remotePublicKey})`
    );

    connection.addPlugin(new PromisePlugin());
    await connection.waitForOpen();

    try {
        // ######## Phase 1: Connection Establishment ########
        MessageBus.send('debug', `${connection.id}: Phase 1: establish connection`);

        // Phase 1.1: Request communication
        MessageBus.send('debug', `${connection.id}: Phase 1.1: send communication_request`);
        await sendUnencryptedClientMessage(connection, {
            command: 'communication_request',
            sourcePublicKey: localPublicKey,
            targetPublicKey: remotePublicKey
        });

        // Phase 1.2: Wait for the other side to signal us that it is ready to receive data
        MessageBus.send('debug', `${connection.id}: Phase 1.2: wait for communication_ready`);
        await waitForUnencryptedServerMessage(connection, 'communication_ready');

        // ######## Phase 2: Setup encryption ########
        MessageBus.send('debug', `${connection.id}: Phase 2: exchange keys`);

        // Phase 2.1: Generate keypair and send the public key to the other side
        MessageBus.send(
            'debug',
            `${connection.id}: Phase 2.1: generate encrypt and send public key`
        );

        const tempKeyPair = tweetnacl.box.keyPair();
        connection.send(cryptoApi.encryptAndEmbedNonce(tempKeyPair.publicKey));

        // Phase 2.2: Wait for the public key from the other side
        MessageBus.send('debug', `${connection.id}: Phase 2.2: wait for and decrypt public key`);

        const publicKeyOther = cryptoApi.decryptWithEmbeddedNonce(
            await connection.promisePlugin().waitForBinaryMessage()
        );

        // Phase 2.3: Derive shared key and setup encrypted connection object
        MessageBus.send('debug', `${connection.id}: Phase 2.3: derive shared key`);

        const sharedKey = tweetnacl.box.before(publicKeyOther, tempKeyPair.secretKey);
        connection.addPlugin(new EncryptionPlugin(sharedKey, false), {before: 'promise'});
        connection.addPlugin(new KeepAlivePlugin(KEEPALIVE_TIMER, KEEPALIVE_TIMEOUT), {
            before: 'promise'
        });
        connection.addPlugin(new FragmentationPlugin(FRAGMENTATION_CHUNKSIZE), {before: 'promise'});

        MessageBus.send(
            'debug',
            `${connection.id} connectWithEncryption(${url}, ${localPublicKey}, ${remotePublicKey}) - success`
        );
        return {
            connection,
            myKey: cryptoApi.localPublicKey,
            remoteKey: cryptoApi.remotePublicKey
        };
    } catch (e) {
        MessageBus.send(
            'debug',
            `${connection.id} connectWithEncryption(${url}, ${localPublicKey}, ${remotePublicKey}) - failure: ${e}`
        );
        connection.close(e.toString());
        throw e;
    }
}

/**
 * Establish an encrypted connection to a target - if not successful retries.
 *
 * This is exactly the same as connectWithEncryption, except that the returned promise does not
 * reject when the connection establishment failed. In this case it just retires. There is only
 * one way to
 *
 * @param url
 * @param cryptoApi
 * @param retryTimeouts - A list of timeouts to use to establish outgoing connections
 */
export function connectWithEncryptionUntilSuccessful(
    url: string,
    cryptoApi: SymmetricCryptoApiWithKeys,
    retryTimeouts: number[] = [5000, 10000, 20000, 30000, 60000, 120000]
): StoppablePromise<ConnectionInfo> {
    const localPublicKey = castToLocalPublicKey(cryptoApi.localPublicKey);
    const remotePublicKey = castToRemotePublicKey(cryptoApi.remotePublicKey);

    MessageBus.send(
        'log',
        `connectWithEncryptionUntilSuccessful(${url}, ${localPublicKey}, ${remotePublicKey})`
    );

    // eslint-disable-next-line func-style
    let stopLoop = (): void => undefined;

    async function startLoop(): Promise<ConnectionInfo> {
        let stopped = false;
        const retryTimeoutList = retryTimeouts.length === 0 ? [5000] : retryTimeouts;

        stopLoop = () => {
            stopped = true;
        };

        while (!stopped) {
            try {
                // Try to establish a connection
                // eslint-disable-next-line no-await-in-loop
                const connInfo = await connectWithEncryption(url, cryptoApi);

                // If a connection was established after stop was called we still reject the
                // promise, because it makes caller code easier if stop() guarantees a reject.
                if (stopped) {
                    connInfo.connection.close('Stopped by user');
                    break;
                }

                MessageBus.send(
                    'log',
                    `${connInfo.connection.id} connectWithEncryptionUntilSuccessful(${url}, ${localPublicKey}, ${remotePublicKey}) - success`
                );

                return connInfo;
            } catch (ignore) {
                if (stopped) {
                    break;
                }

                // eslint-disable-next-line no-await-in-loop
                await new Promise<void>((resolve, reject) => {
                    MessageBus.send(
                        'log',
                        `connectWithEncryptionUntilSuccessful(${url}, ${localPublicKey}, ${remotePublicKey}) - next retry in ${retryTimeoutList[0]} ms.`
                    );

                    const retryTimeoutHandle = setTimeout(() => {
                        stopLoop = () => {
                            stopped = true;
                        };
                        resolve();
                    }, retryTimeoutList[0]);

                    if (retryTimeoutList.length > 1) {
                        retryTimeoutList.splice(0, 1);
                    }

                    stopLoop = () => {
                        clearTimeout(retryTimeoutHandle);
                        reject(new Error('Stopped by user'));
                    };
                });
            }
        }

        throw new Error('Stopped by user');
    }

    // Construct and return the stoppable promise
    const promise = startLoop() as StoppablePromise<ConnectionInfo>;

    // We can't use the stopHandler her directly, because it might change its value.
    promise.stop = () => {
        stopLoop();
    };

    return promise;
}

/**
 * Accept a connection and do the encryption handshaking to setup an encrypted connection.
 *
 * This is the opposite of connectWithEncryption, so for more information have a look at the
 * documentation of that function.
 * If something goes wrong the passed websocket connection will be closed.
 *
 * @param connection
 * @param cryptoApis
 */
export async function acceptWithEncryption(
    connection: Connection,
    cryptoApis: CryptoApi[]
): Promise<ConnectionInfo> {
    MessageBus.send('log', `acceptWithEncryption(${connection.id})`);

    try {
        // ######## Phase 1: Connection Establishment ########
        MessageBus.send('debug', `${connection.id}: Phase 1: accept connection`);

        // Phase 1.1: Wait for the communication request
        MessageBus.send('debug', `${connection.id}: Phase 1.1: wait for communication_request`);

        const request = await waitForUnencryptedClientMessage(connection, 'communication_request');
        const localPublicKey = ensurePublicKey(hexToUint8Array(request.targetPublicKey));
        const remotePublicKey = ensurePublicKey(hexToUint8Array(request.sourcePublicKey));

        MessageBus.send(
            'debug',
            `${connection.id}: Phase 1.1x: ${request.targetPublicKey} ${
                request.sourcePublicKey
            } [${cryptoApis.map(api => uint8arrayToHexString(api.publicEncryptionKey)).join(',')}]`
        );

        // Phase 1.2: Signal the other side that we are ready to receive messages
        MessageBus.send('debug', `${connection.id}: Phase 1.2: send communication_ready`);
        await sendUnencryptedServerMessage(connection, {command: 'communication_ready'});

        // ######## Special Phase: Check if we want to accept the other side ########
        MessageBus.send('debug', `${connection.id}: Phase 1.3: check our desire to communicate`);

        // Phase 1.3: Check whether the request has come through the right endpoint - so if we
        // have a crypto api that can serve the requested public key
        let cryptoApi;

        for (const potentialCryptoApi of cryptoApis) {
            if (tweetnacl.verify(localPublicKey, potentialCryptoApi.publicEncryptionKey)) {
                cryptoApi = potentialCryptoApi;
                // No break here, so that the loop execution time stays constant
                // compared between success and failure. This constant time doesn't give us much
                // right now, because the code changed and I cannot proof it against certain
                // spy scenarios right now, so we need to reevaluate attack vectors. Perhaps we
                // don't need the constant time ... but let's keep it for now.
            }
        }

        // Phase 1.4: Check whether our id wants to communicate with the other side
        // This step should also run in constant time ... but we can't decide it here. We would have to
        // 1) call a callback or
        // 2) we also get an array of allowed peers for a given public key
        // ... but let's do this later.
        // TODO: implement this step (select communication partners)
        MessageBus.send(
            'debug',
            `${connection.id}: Phase 1.3: ${cryptoApi ? 'accepted' : 'rejected'}`
        );

        if (!cryptoApi) {
            throw new Error('We do not accept connections for this target public key');
        }

        // ######## Phase 2: Setup encryption ########
        MessageBus.send('debug', `${connection.id}: Phase 2: exchange keys`);

        // Phase 2.2: Wait for the public key from the other side
        MessageBus.send('debug', `${connection.id}: Phase 2.1: wait for and decrypt public key`);

        const encKey = await connection.promisePlugin().waitForBinaryMessage();
        const publicKeyOther = cryptoApi.decryptWithEmbeddedNonce(encKey, remotePublicKey);

        // Note that termination of a connection should always be done after the peer proved,
        // that it has the private key, but before we proved, that we have our public key. This
        // means that we don't expose any information about what identities we have, because the
        // following scenarios terminate at the same point in protocol and also if possible at
        // the exact same time (side channel timing attacks!)
        // - we don't know the person and don't want to communicate with it
        // - we are not the identity that the other side wants to connect to

        // Phase 2.2: Generate keypair and send the public key to the other side
        MessageBus.send(
            'debug',
            `${connection.id}: Phase 2.2: generate encrypt and send public key`
        );

        const tempKeyPair = tweetnacl.box.keyPair();
        connection.send(cryptoApi.encryptAndEmbedNonce(tempKeyPair.publicKey, remotePublicKey));

        // Phase 2.3: Derive shared key and setup encrypted connection object
        MessageBus.send('debug', `${connection.id}: Phase 2.3: derive shared key`);
        const sharedKey = tweetnacl.box.before(publicKeyOther, tempKeyPair.secretKey);
        MessageBus.send('debug', `${connection.id}: Phase 2.3: derive shared key - END`);
        connection.addPlugin(new EncryptionPlugin(sharedKey, true), {before: 'promise'});
        connection.addPlugin(new KeepAlivePlugin(KEEPALIVE_TIMER, KEEPALIVE_TIMEOUT), {
            before: 'promise'
        });
        connection.addPlugin(new FragmentationPlugin(FRAGMENTATION_CHUNKSIZE), {before: 'promise'});

        MessageBus.send(
            'log',
            `acceptWithEncryption(${connection.id}, ${uint8arrayToHexString(
                localPublicKey
            )}, ${uint8arrayToHexString(remotePublicKey)}) - success`
        );
        return {
            connection,
            myKey: localPublicKey,
            remoteKey: remotePublicKey
        };
    } catch (e) {
        MessageBus.send('log', `acceptWithEncryption(${connection.id}) - failure: ${e}`);
        connection.close(e && isFunction(e.toString) ? e.toString() : undefined);
        throw e;
    }
}
